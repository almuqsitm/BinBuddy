from fastapi import FastAPI, HTTPException, Body
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from supabase import create_client, Client
from dotenv import load_dotenv
import os

# running backend uvicorn main:app --reload
# 1. LOAD SECRETS
# This reads the .env file so we can access SUPABASE_URL and SUPABASE_KEY
load_dotenv()

url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")

if not url or not key:
    raise ValueError("Missing SUPABASE_URL or SUPABASE_KEY in .env file")

# 2. CONNECT TO DATABASE
# This creates the "phone line" to Supabase.
supabase: Client = create_client(url, key)

# 3. INITIALIZE APP
# This creates the actual Web Server.
app = FastAPI()

# --- CORS MIDDLEWARE (Crucial for Frontend to Frontend communication) ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"], # Vite Frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 4. DATA MODELS (Pydantic)
# These are "Blueprints". They force data to look a certain way.
# If the frontend sends a task without a "title", this will block it.

class TaskCreate(BaseModel):
    title: str
    assigned_to: str  # UUID of the Janitor
    created_by: str   # UUID of the Supervisor

class TaskUpdate(BaseModel):
    is_completed: bool

class ConnectionRequest(BaseModel):
    supervisor_id: str
    friend_code: str

# 5. API ENDPOINTS (The Buttons)

@app.get("/")
def home():
    """Simple check to see if the server is running."""
    return {"message": "BinBuddy Backend is Running!"}

# --- PROFILES & TEAMS ---

@app.post("/profiles")
def create_profile(profile: dict = Body(...)):
    """
    Create/Update profile. Friend Code is auto-generated by DB default.
    """
    response = supabase.table("profiles").upsert(profile).execute()
    return response.data

@app.post("/connect")
def connect_supervisor_to_janitor(req: ConnectionRequest):
    """
    Supervisor enters a Friend Code to connect with a Janitor.
    """
    # 1. Find Janitor by Friend Code
    janitor_res = supabase.table("profiles").select("*").eq("friend_code", req.friend_code).eq("role", "janitor").execute()
    
    if not janitor_res.data:
        raise HTTPException(status_code=404, detail="Invalid Friend Code or user is not a Janitor.")
    
    janitor = janitor_res.data[0]
    
    # 2. Create Connection
    try:
        connection = {
            "supervisor_id": req.supervisor_id,
            "janitor_id": janitor['id']
        }
        response = supabase.table("connections").insert(connection).execute()
        return {"message": f"Successfully connected with {janitor.get('first_name', 'Janitor')}", "data": response.data}
    except Exception as e:
        raise HTTPException(status_code=400, detail="Connection already exists or failed.")

@app.get("/my-team/{supervisor_id}")
def get_my_team(supervisor_id: str):
    """
    Get all Janitors connected to this Supervisor.
    """
    # For MVP: Step 1 Get IDs, Step 2 Get Profiles
    conns = supabase.table("connections").select("janitor_id").eq("supervisor_id", supervisor_id).execute()
    
    if not conns.data:
        return []
        
    janitor_ids = [c['janitor_id'] for c in conns.data]
    profiles = supabase.table("profiles").select("*").in_("id", janitor_ids).execute()
    return profiles.data

# --- TASKS ---

@app.get("/tasks")
def get_tasks():
    """
    Fetch all tasks from the database.
    In the future, we will filter this by who is logged in.
    """
    # .table("tasks").select("*") -> Translated to SQL: SELECT * FROM tasks
    response = supabase.table("tasks").select("*").execute()
    return response.data

@app.post("/tasks")
def create_task(task: TaskCreate):
    """
    Create a new task.
    Expecting JSON: {"title": "Clean Sink", "assigned_to": "...", "created_by": "..."}
    """
    try:
        # data=task.dict() converts our Python object to a JSON dictionary
        response = supabase.table("tasks").insert(task.dict()).execute()
        return response.data
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.patch("/tasks/{task_id}")
def update_task(task_id: int, update: TaskUpdate):
    """
    Update a task (e.g. mark as Done).
    """
    try:
        response = supabase.table("tasks").update(update.dict()).eq("id", task_id).execute()
        return response.data
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
